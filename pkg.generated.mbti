// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/moon_rodio"

import {
  "Milky2018/moon_cpal/core",
  "Milky2018/moon_cpal/spec",
  "Milky2018/moon_rodio/decoder",
}

// Values
pub fn[S : Source] amplify(S, Double) -> DynSource

pub fn[S : Source] amplify_decibel(S, Double) -> DynSource

pub fn[S : Source] amplify_normalized(S, Double) -> DynSource

pub fn[S : Source] buffered(S) -> SamplesBuffer

pub fn[S : Source] channel_volume(S, Array[Double]) -> DynSource

pub fn chirp(Int, Double, Double, @core.Duration) -> Chirp

pub fn[S : Source] convert_channels(S, Int) -> DynSource

pub fn[S : Source] convert_sample_rate(S, Int) -> DynSource

pub fn[A : Source, B : Source] crossfade(A, B, @core.Duration) -> DynSource

pub fn[S : Source] delay(S, @core.Duration) -> DynSource

pub fn[S : Source] distortion(S, Double) -> DynSource

pub fn empty(Int, Int) -> DynSource

pub fn[S : Source] fade_in(S, @core.Duration) -> DynSource

pub fn[S : Source] fade_out(S, @core.Duration) -> DynSource

pub fn[S : Source] from_factory(() -> S?) -> FromFactoryIter[S]

pub fn from_iter(Int, Int, Array[Double]) -> SamplesBuffer

pub fn from_source_iter(Array[DynSource]) -> FromIter

pub fn[S : Source] limit(S, Double, Double) -> DynSource

pub fn[S : Source] linear_gain_ramp(S, Double, Double, @core.Duration) -> DynSource

pub fn[A : Source, B : Source] mix(A, B) -> DynSource

pub fn mixer(Int, Int) -> (Mixer, MixerSource)

pub fn[S : Source] pausable(S, Bool) -> Pausable

pub fn[S : Source] periodic_access(S, Int, () -> Unit) -> PeriodicAccess

pub fn play(Mixer, Bytes) -> Sink raise PlayError

pub fn queue(Bool) -> (SourcesQueueInput, SourcesQueueOutput)

pub fn[S : Source] repeat_infinite(S) -> DynSource

pub fn[S : Source] skip_duration(S, @core.Duration) -> DynSource

pub fn[S : Source] skippable(S) -> Skippable

pub fn[S : Source] speed(S, Double) -> DynSource

pub fn[S : Source] stoppable(S) -> Stoppable

pub fn supported_output_configs(@spec.Device) -> Array[@core.SupportedStreamConfig] raise StreamError

pub fn[S : Source] take(S, Int) -> DynSource

pub fn[S : Source] take_duration(S, @core.Duration) -> DynSource

pub fn[S : Source] to_dyn(S) -> DynSource

pub fn[S : Source] track_position(S) -> TrackPosition

pub fn[S : Source] uniform(S, Int, Int) -> DynSource

pub fn zero(Int, Int) -> DynSource

// Errors
pub suberror DecoderError {
  Backend(@decoder.DecoderError)
  UnknownFormat
}
pub impl Eq for DecoderError
pub impl Show for DecoderError

pub suberror PlayError {
  Decode(DecoderError)
}
pub impl Eq for PlayError
pub impl Show for PlayError

pub suberror SeekError {
  NotSupported
}
pub fn SeekError::source_intact(Self) -> Bool
pub impl Eq for SeekError
pub impl Show for SeekError

pub suberror StreamError {
  PlayStreamError(@core.PlayStreamError)
  DefaultStreamConfigError(@core.DefaultStreamConfigError)
  BuildStreamError(@core.BuildStreamError)
  SupportedStreamConfigsError(@core.SupportedStreamConfigsError)
  NoDevice
  UnsupportedSampleFormat
}
pub impl Eq for StreamError
pub impl Show for StreamError

// Types and methods
pub struct Amplify {
  inner : DynSource
}
pub fn[S : Source] Amplify::new(S, Double) -> Self
pub impl Source for Amplify

pub struct Buffered {
  inner : SamplesBuffer
}
pub fn Buffered::channels(Self) -> Int
pub fn[S : Source] Buffered::new(S) -> Self
pub fn Buffered::next(Self) -> Double?
pub fn Buffered::sample_rate(Self) -> Int
pub impl Source for Buffered

pub struct ChannelVolume {
  inner : DynSource
}
pub fn[S : Source] ChannelVolume::new(S, Array[Double]) -> Self
pub impl Source for ChannelVolume

pub struct Chirp {
  sample_rate : Int
  start_frequency : Double
  end_frequency : Double
  total_samples : Int
  elapsed_samples : Ref[Int]
  phase : Ref[Double]
}
pub fn Chirp::channels(Self) -> Int
pub fn Chirp::next(Self) -> Double?
pub fn Chirp::sample_rate(Self) -> Int
pub impl Source for Chirp

pub struct ControlledQueueSource {
  inner : SourcesQueueOutput
  controls : SinkControls
}
pub fn ControlledQueueSource::channels(Self) -> Int
pub fn ControlledQueueSource::next(Self) -> Double?
pub fn ControlledQueueSource::sample_rate(Self) -> Int
pub impl Source for ControlledQueueSource

pub struct Crossfade {
  inner : DynSource
}
pub fn[A : Source, B : Source] Crossfade::new(A, B, @core.Duration) -> Self
pub impl Source for Crossfade

pub struct Decoder {
  inner : @decoder.DecodedSamples
}
pub fn Decoder::channels(Self) -> Int
pub fn Decoder::new(Bytes) -> Self raise DecoderError
pub fn Decoder::new_flac(Bytes) -> Self raise DecoderError
pub fn Decoder::new_mp3(Bytes) -> Self raise DecoderError
pub fn Decoder::new_vorbis(Bytes) -> Self raise DecoderError
pub fn Decoder::new_wav(Bytes) -> Self raise DecoderError
pub fn Decoder::next(Self) -> Double?
pub fn Decoder::sample_rate(Self) -> Int
pub impl Source for Decoder

pub struct Delay {
  inner : DynSource
}
pub fn[S : Source] Delay::new(S, @core.Duration) -> Self
pub impl Source for Delay

pub struct Distortion {
  inner : DynSource
}
pub fn[S : Source] Distortion::new(S, Double) -> Self
pub impl Source for Distortion

pub struct Done {
  input : DynSource
  signal : Ref[Int]
  signal_sent : Ref[Bool]
}
pub fn Done::channels(Self) -> Int
pub fn[S : Source] Done::new(S, Ref[Int]) -> Self
pub fn Done::next(Self) -> Double?
pub fn Done::sample_rate(Self) -> Int
pub impl Source for Done

pub struct DynSource {
  next_sample : () -> Double?
  channels : Int
  sample_rate : Int
}
pub fn DynSource::channels(Self) -> Int
pub fn DynSource::new(() -> Double?, Int, Int) -> Self
pub fn DynSource::next(Self) -> Double?
pub fn DynSource::sample_rate(Self) -> Int
pub impl Source for DynSource

pub struct Empty {
  inner : DynSource
}
pub fn Empty::new(Int, Int) -> Self
pub impl Source for Empty

pub struct EmptyCallback {
  callback : () -> Unit
  called : Ref[Bool]
}
pub fn EmptyCallback::channels(Self) -> Int
pub fn EmptyCallback::new(() -> Unit) -> Self
pub fn EmptyCallback::next(Self) -> Double?
pub fn EmptyCallback::sample_rate(Self) -> Int
pub impl Source for EmptyCallback

pub struct FadeIn {
  inner : DynSource
}
pub fn[S : Source] FadeIn::new(S, @core.Duration) -> Self
pub impl Source for FadeIn

pub struct FadeOut {
  inner : DynSource
}
pub fn[S : Source] FadeOut::new(S, @core.Duration) -> Self
pub impl Source for FadeOut

pub struct FromFactoryIter[S] {
  factory : () -> S?
  current : Ref[DynSource?]
  channels : Ref[Int]
  sample_rate : Ref[Int]
}
pub fn[S] FromFactoryIter::channels(Self[S]) -> Int
pub fn[S : Source] FromFactoryIter::next(Self[S]) -> Double?
pub fn[S] FromFactoryIter::sample_rate(Self[S]) -> Int
pub impl[S : Source] Source for FromFactoryIter[S]

pub struct FromIter {
  sources : Ref[Array[DynSource]]
  current : Ref[DynSource]
  has_current : Ref[Bool]
}
pub fn FromIter::channels(Self) -> Int
pub fn FromIter::next(Self) -> Double?
pub fn FromIter::sample_rate(Self) -> Int
pub impl Source for FromIter

pub enum Function {
  Sine
  Triangle
  Square
  Sawtooth
}
pub fn Function::sawtooth() -> Self
pub fn Function::sine() -> Self
pub fn Function::square() -> Self
pub fn Function::triangle() -> Self
pub impl Eq for Function
pub impl Show for Function

pub struct GeneratorFunction {
  generator : (Double) -> Double
}
pub fn GeneratorFunction::new((Double) -> Double) -> Self

pub struct Limit {
  inner : DynSource
}
pub fn[S : Source] Limit::new(S, LimitSettings) -> Self
pub impl Source for Limit

pub struct LimitSettings {
  min_value : Double
  max_value : Double
}
pub fn LimitSettings::default() -> Self
pub fn LimitSettings::new() -> Self
pub fn LimitSettings::with_max(Self, Double) -> Self
pub fn LimitSettings::with_min(Self, Double) -> Self
pub impl Eq for LimitSettings
pub impl Show for LimitSettings

pub struct LinearGainRamp {
  inner : DynSource
}
pub fn[S : Source] LinearGainRamp::new(S, Double, Double, @core.Duration) -> Self
pub impl Source for LinearGainRamp

pub struct Mix {
  inner : DynSource
}
pub fn[A : Source, B : Source] Mix::new(A, B) -> Self
pub impl Source for Mix

pub struct Mixer {
  has_pending : Ref[Bool]
  pending_sources : Ref[Array[DynSource]]
  channels : Int
  sample_rate : Int
}
pub fn[S : Source] Mixer::add(Self, S) -> Unit

pub struct MixerSource {
  current_sources : Ref[Array[DynSource]]
  input : Mixer
  sample_count : Ref[Int]
}
pub fn MixerSource::channels(Self) -> Int
pub fn MixerSource::next(Self) -> Double?
pub fn MixerSource::sample_rate(Self) -> Int
pub impl Source for MixerSource

pub struct OutputStream {
  config : OutputStreamConfig
  mixer : Mixer
  _stream : @spec.Stream
  log_on_drop : Ref[Bool]
}
pub fn OutputStream::config(Self) -> OutputStreamConfig
pub fn OutputStream::log_on_drop(Self, Bool) -> Unit
pub fn OutputStream::mixer(Self) -> Mixer
pub fn OutputStream::open(@spec.Device, OutputStreamConfig, (@core.StreamError) -> Unit) -> Self raise StreamError

pub struct OutputStreamBuilder {
  device : @spec.Device?
  config : OutputStreamConfig
  error_callback : (@core.StreamError) -> Unit
}
pub fn OutputStreamBuilder::default() -> Self
pub fn OutputStreamBuilder::from_default_device() -> Self raise StreamError
pub fn OutputStreamBuilder::from_device(@spec.Device) -> Self raise StreamError
pub fn OutputStreamBuilder::open_default_stream() -> OutputStream raise StreamError
pub fn OutputStreamBuilder::open_stream(Self) -> OutputStream raise StreamError
pub fn OutputStreamBuilder::open_stream_or_fallback(Self) -> OutputStream raise StreamError
pub fn OutputStreamBuilder::with_buffer_size(Self, @core.BufferSize) -> Self
pub fn OutputStreamBuilder::with_channels(Self, Int) -> Self
pub fn OutputStreamBuilder::with_config(Self, @core.StreamConfig) -> Self
pub fn OutputStreamBuilder::with_device(Self, @spec.Device) -> Self
pub fn OutputStreamBuilder::with_error_callback(Self, (@core.StreamError) -> Unit) -> Self
pub fn OutputStreamBuilder::with_sample_format(Self, @core.SampleFormat) -> Self
pub fn OutputStreamBuilder::with_sample_rate(Self, Int) -> Self
pub fn OutputStreamBuilder::with_supported_config(Self, @core.SupportedStreamConfig) -> Self

pub struct OutputStreamConfig {
  channel_count : Int
  sample_rate : Int
  buffer_size : @core.BufferSize
  sample_format : @core.SampleFormat
}
pub fn OutputStreamConfig::buffer_size(Self) -> @core.BufferSize
pub fn OutputStreamConfig::channel_count(Self) -> Int
pub fn OutputStreamConfig::default() -> Self
pub fn OutputStreamConfig::sample_format(Self) -> @core.SampleFormat
pub fn OutputStreamConfig::sample_rate(Self) -> Int
pub impl Eq for OutputStreamConfig
pub impl Show for OutputStreamConfig

pub struct Pausable {
  input : DynSource
  paused : Ref[Bool]
  remaining_paused_samples : Ref[Int]
}
pub fn Pausable::channels(Self) -> Int
pub fn Pausable::is_paused(Self) -> Bool
pub fn Pausable::next(Self) -> Double?
pub fn Pausable::sample_rate(Self) -> Int
pub fn Pausable::set_paused(Self, Bool) -> Unit
pub impl Source for Pausable

pub struct PeriodicAccess {
  input : DynSource
  every_samples : Int
  remaining : Ref[Int]
  callback : () -> Unit
}
pub fn PeriodicAccess::channels(Self) -> Int
pub fn PeriodicAccess::next(Self) -> Double?
pub fn PeriodicAccess::sample_rate(Self) -> Int
pub impl Source for PeriodicAccess

pub struct Repeat {
  inner : DynSource
}
pub fn[S : Source] Repeat::new(S) -> Self
pub impl Source for Repeat

pub struct SamplesBuffer {
  channels : Int
  sample_rate : Int
  samples : Array[Double]
  cursor : Ref[Int]
}
pub fn SamplesBuffer::amplify(Self, Double) -> DynSource
pub fn SamplesBuffer::channels(Self) -> Int
pub fn SamplesBuffer::new(Int, Int, Array[Double]) -> Self
pub fn SamplesBuffer::next(Self) -> Double?
pub fn SamplesBuffer::repeat_infinite(Self) -> DynSource
pub fn SamplesBuffer::sample_rate(Self) -> Int
pub impl Source for SamplesBuffer

pub struct SawtoothWave {
  inner : SignalGenerator
}
pub fn SawtoothWave::channels(Self) -> Int
pub fn SawtoothWave::new(Double) -> Self
pub fn SawtoothWave::next(Self) -> Double?
pub fn SawtoothWave::sample_rate(Self) -> Int
pub impl Source for SawtoothWave

pub enum SignalFunction {
  Sine
  Square
  Sawtooth
  Triangle
}
pub impl Eq for SignalFunction
pub impl Show for SignalFunction

pub struct SignalGenerator {
  channels : Int
  sample_rate : Int
  frequency : Double
  function : SignalFunction
  phase : Ref[Double]
}
pub fn SignalGenerator::channels(Self) -> Int
pub fn SignalGenerator::from_function(Int, Double, Function) -> Self
pub fn SignalGenerator::new(Int, Double, SignalFunction) -> Self
pub fn SignalGenerator::next(Self) -> Double?
pub fn SignalGenerator::sample_rate(Self) -> Int
pub fn SignalGenerator::with_generator(Int, Double, GeneratorFunction) -> DynSource
pub impl Source for SignalGenerator

pub struct SineWave {
  inner : SignalGenerator
}
pub fn SineWave::channels(Self) -> Int
pub fn SineWave::new(Double) -> Self
pub fn SineWave::next(Self) -> Double?
pub fn SineWave::sample_rate(Self) -> Int
pub impl Source for SineWave

pub struct Sink {
  queue_tx : SourcesQueueInput
  controls : SinkControls
  detached : Ref[Bool]
}
pub fn[S : Source] Sink::append(Self, S) -> Unit
pub fn Sink::clear(Self) -> Unit
pub fn Sink::connect_new(Mixer) -> Self
pub fn Sink::detach(Self) -> Unit
pub fn Sink::empty(Self) -> Bool
pub fn Sink::get_pos(Self) -> @core.Duration
pub fn Sink::is_paused(Self) -> Bool
pub fn Sink::len(Self) -> Int
pub fn Sink::new() -> (Self, ControlledQueueSource)
pub fn Sink::pause(Self) -> Unit
pub fn Sink::play(Self) -> Unit
pub fn Sink::set_speed(Self, Double) -> Unit
pub fn Sink::set_volume(Self, Double) -> Unit
pub fn Sink::skip_one(Self) -> Unit
pub fn Sink::sleep_until_end(Self) -> Unit
pub fn Sink::speed(Self) -> Double
pub fn Sink::stop(Self) -> Unit
pub fn Sink::try_seek(Self, @core.Duration) -> Unit raise SeekError
pub fn Sink::volume(Self) -> Double

pub struct SinkControls {
  pause : Ref[Bool]
  stopped : Ref[Bool]
  skip_one : Ref[Bool]
  volume : Ref[Double]
  speed : Ref[Double]
  sound_count : Ref[Int]
  position_samples : Ref[Int]
  position_sample_rate : Ref[Int]
}

pub struct SkipDuration {
  inner : DynSource
}
pub fn[S : Source] SkipDuration::new(S, @core.Duration) -> Self
pub impl Source for SkipDuration

pub struct Skippable {
  input : DynSource
  do_skip : Ref[Bool]
}
pub fn Skippable::channels(Self) -> Int
pub fn Skippable::next(Self) -> Double?
pub fn Skippable::sample_rate(Self) -> Int
pub fn Skippable::skip(Self) -> Unit
pub impl Source for Skippable

pub struct SourcesQueueInput {
  next_sounds : Ref[Array[DynSource]]
  keep_alive_if_empty : Ref[Bool]
  reset_version : Ref[Int]
}
pub fn[S : Source] SourcesQueueInput::append(Self, S) -> Unit
pub fn SourcesQueueInput::clear(Self) -> Int
pub fn SourcesQueueInput::set_keep_alive_if_empty(Self, Bool) -> Unit

pub struct SourcesQueueOutput {
  current : Ref[DynSource]
  current_is_fallback : Ref[Bool]
  prefetched : Ref[Double?]
  has_prefetched : Ref[Bool]
  seen_reset_version : Ref[Int]
  input : SourcesQueueInput
}
pub fn SourcesQueueOutput::channels(Self) -> Int
pub fn SourcesQueueOutput::next(Self) -> Double?
pub fn SourcesQueueOutput::sample_rate(Self) -> Int
pub fn SourcesQueueOutput::skip_one(Self) -> Unit
pub impl Source for SourcesQueueOutput

pub struct Spatial {
  inner : SpatialSource
}
pub fn Spatial::channels(Self) -> Int
pub fn[S : Source] Spatial::new(S, Array[Double], Array[Double], Array[Double]) -> Self
pub fn Spatial::next(Self) -> Double?
pub fn Spatial::sample_rate(Self) -> Int
pub fn Spatial::set_positions(Self, Array[Double], Array[Double], Array[Double]) -> Unit
pub impl Source for Spatial

pub struct SpatialSink {
  sink : Sink
  emitter_position : Ref[Array[Double]]
  left_ear : Ref[Array[Double]]
  right_ear : Ref[Array[Double]]
}
pub fn[S : Source] SpatialSink::append(Self, S) -> Unit
pub fn SpatialSink::clear(Self) -> Unit
pub fn SpatialSink::connect_new(Mixer, Array[Double], Array[Double], Array[Double]) -> Self
pub fn SpatialSink::detach(Self) -> Unit
pub fn SpatialSink::empty(Self) -> Bool
pub fn SpatialSink::get_pos(Self) -> @core.Duration
pub fn SpatialSink::is_paused(Self) -> Bool
pub fn SpatialSink::len(Self) -> Int
pub fn SpatialSink::pause(Self) -> Unit
pub fn SpatialSink::play(Self) -> Unit
pub fn SpatialSink::set_emitter_position(Self, Array[Double]) -> Unit
pub fn SpatialSink::set_left_ear_position(Self, Array[Double]) -> Unit
pub fn SpatialSink::set_right_ear_position(Self, Array[Double]) -> Unit
pub fn SpatialSink::set_speed(Self, Double) -> Unit
pub fn SpatialSink::set_volume(Self, Double) -> Unit
pub fn SpatialSink::skip_one(Self) -> Unit
pub fn SpatialSink::sleep_until_end(Self) -> Unit
pub fn SpatialSink::speed(Self) -> Double
pub fn SpatialSink::stop(Self) -> Unit
pub fn SpatialSink::try_seek(Self, @core.Duration) -> Unit raise SeekError
pub fn SpatialSink::volume(Self) -> Double

pub struct SpatialSource {
  input : DynSource
  emitter_position : Ref[Array[Double]]
  left_ear : Ref[Array[Double]]
  right_ear : Ref[Array[Double]]
  left_gain : Ref[Double]
  right_gain : Ref[Double]
  pending_mono : Ref[Double]
  has_pending : Ref[Bool]
  pending_channel : Ref[Int]
}
pub fn SpatialSource::channels(Self) -> Int
pub fn[S : Source] SpatialSource::new(S, Array[Double], Array[Double], Array[Double]) -> Self
pub fn SpatialSource::next(Self) -> Double?
pub fn SpatialSource::sample_rate(Self) -> Int
pub fn SpatialSource::set_positions(Self, Array[Double], Array[Double], Array[Double]) -> Unit
pub impl Source for SpatialSource

pub struct Speed {
  inner : DynSource
}
pub fn[S : Source] Speed::new(S, Double) -> Self
pub impl Source for Speed

pub struct SquareWave {
  inner : SignalGenerator
}
pub fn SquareWave::channels(Self) -> Int
pub fn SquareWave::new(Double) -> Self
pub fn SquareWave::next(Self) -> Double?
pub fn SquareWave::sample_rate(Self) -> Int
pub impl Source for SquareWave

pub struct StaticSamplesBuffer {
  channels : Int
  sample_rate : Int
  samples : Array[Double]
  cursor : Ref[Int]
}
pub fn StaticSamplesBuffer::channels(Self) -> Int
pub fn StaticSamplesBuffer::new(Int, Int, Array[Double]) -> Self
pub fn StaticSamplesBuffer::next(Self) -> Double?
pub fn StaticSamplesBuffer::sample_rate(Self) -> Int
pub impl Source for StaticSamplesBuffer

pub struct Stoppable {
  input : DynSource
  stopped : Ref[Bool]
}
pub fn Stoppable::channels(Self) -> Int
pub fn Stoppable::next(Self) -> Double?
pub fn Stoppable::sample_rate(Self) -> Int
pub fn Stoppable::stop(Self) -> Unit
pub impl Source for Stoppable

pub struct TakeDuration {
  inner : DynSource
}
pub fn[S : Source] TakeDuration::new(S, @core.Duration) -> Self
pub impl Source for TakeDuration

pub struct TrackPosition {
  input : DynSource
  played_samples : Ref[Int]
}
pub fn TrackPosition::channels(Self) -> Int
pub fn TrackPosition::get_pos(Self) -> @core.Duration
pub fn TrackPosition::next(Self) -> Double?
pub fn TrackPosition::sample_rate(Self) -> Int
pub impl Source for TrackPosition

pub struct TriangleWave {
  inner : SignalGenerator
}
pub fn TriangleWave::channels(Self) -> Int
pub fn TriangleWave::new(Double) -> Self
pub fn TriangleWave::next(Self) -> Double?
pub fn TriangleWave::sample_rate(Self) -> Int
pub impl Source for TriangleWave

pub struct UniformSourceIterator {
  input : DynSource
  target_channels : Int
  target_sample_rate : Int
}
pub fn UniformSourceIterator::channels(Self) -> Int
pub fn[S : Source] UniformSourceIterator::new(S, Int, Int) -> Self
pub fn UniformSourceIterator::next(Self) -> Double?
pub fn UniformSourceIterator::sample_rate(Self) -> Int
pub impl Source for UniformSourceIterator

pub struct Zero {
  inner : DynSource
}
pub fn Zero::new(Int, Int) -> Self
pub impl Source for Zero

// Type aliases
pub type ChannelCount = Int

pub type Sample = Double

pub type SampleRate = Int

// Traits
pub trait Source {
  next(Self) -> Double?
  channels(Self) -> Int
  sample_rate(Self) -> Int
}

