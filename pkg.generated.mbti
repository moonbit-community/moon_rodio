// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/moon_rodio"

import {
  "Milky2018/moon_cpal/core",
  "Milky2018/moon_cpal/spec",
  "Milky2018/moon_rodio/decoder",
}

// Values
pub fn[S : Source] amplify(S, Double) -> DynSource

pub fn[S : Source] amplify_decibel(S, Double) -> DynSource

pub fn[S : Source] amplify_normalized(S, Double) -> DynSource

pub fn[S : Source] automatic_gain_control(S, Double, @core.Duration, @core.Duration, Double) -> AutomaticGainControl

pub fn buffer_from_iter(Int, Int, Array[Double]) -> SamplesBuffer

pub fn[S : Source] buffered(S) -> SamplesBuffer

pub fn[S : Source] channel_volume(S, Array[Double]) -> DynSource

pub fn chirp(Int, Double, Double, @core.Duration) -> Chirp

pub fn[S : Source] convert_channels(S, Int) -> DynSource

pub fn[S : Source] convert_sample_rate(S, Int) -> DynSource

pub fn[A : Source, B : Source] crossfade(A, B, @core.Duration) -> DynSource

pub fn db_to_linear(Double) -> Double

pub fn[S : Source] delay(S, @core.Duration) -> DynSource

pub fn[S : Source] distortion(S, Double, Double) -> DynSource

pub fn[S : Source] distortion_threshold(S, Double) -> DynSource

pub fn[S : Source] distortion_with_gain(S, Double, Double) -> DynSource

pub fn empty(Int, Int) -> DynSource

pub fn[S : Source] fade_in(S, @core.Duration) -> DynSource

pub fn[S : Source] fade_out(S, @core.Duration) -> DynSource

pub fn[S : Source] fadein(S, @core.Duration) -> DynSource

pub fn[S : Source] fadeout(S, @core.Duration) -> DynSource

pub fn[S : Source] from_factory(() -> S?) -> FromFactoryIter[S]

pub fn[S : Source] from_iter(Array[S]) -> FromIter

pub fn[S : Source] high_pass(S, Int) -> BltFilter

pub fn[S : Source] high_pass_with_q(S, Int, Double) -> BltFilter

pub fn lerp(Double, Double, Int, Int) -> Double

pub fn[S : Source] limit(S, LimitSettings) -> DynSource

pub fn[S : Source] limit_range(S, Double, Double) -> DynSource

pub fn[S : Source] linear_gain_ramp(S, Double, Double, @core.Duration) -> DynSource

pub fn[S : Source] linear_gain_ramp_with_clamp(S, Double, Double, @core.Duration, Bool) -> DynSource

pub fn linear_to_db(Double) -> Double

pub fn[S : Source] low_pass(S, Int) -> BltFilter

pub fn[S : Source] low_pass_with_q(S, Int, Double) -> BltFilter

pub fn[A : Source, B : Source] mix(A, B) -> DynSource

pub fn mixer(Int, Int) -> (Mixer, MixerSource)

pub fn[S : Source] output_to_wav(S, StringView) -> Unit

pub fn[S : Source] pausable(S, Bool) -> Pausable

pub fn[S : Source] periodic(S, @core.Duration, () -> Unit) -> PeriodicAccess

pub fn[S : Source] periodic_access(S, Int, () -> Unit) -> PeriodicAccess

pub fn[S : Source] periodic_access_with_source(S, Int, (DynSource) -> Unit) -> PeriodicAccess

pub fn[S : Source] periodic_with_source(S, @core.Duration, (DynSource) -> Unit) -> PeriodicAccess

pub fn pink(Int) -> Pink

pub fn play(Mixer, Bytes) -> Sink raise PlayError

pub fn queue(Bool) -> (SourcesQueueInput, SourcesQueueOutput)

pub fn[S : Source] repeat(S) -> DynSource

pub fn[S : Source] repeat_infinite(S) -> DynSource

pub fn[S : Source] reverb(S, @core.Duration, Double) -> DynSource

pub fn[S : Source] skip_duration(S, @core.Duration) -> DynSource

pub fn[S : Source] skippable(S) -> Skippable

pub fn[S : Source] speed(S, Double) -> DynSource

pub fn[S : Source] stoppable(S) -> Stoppable

pub fn supported_output_configs(@spec.Device) -> Array[@core.SupportedStreamConfig] raise StreamError

pub fn[S : Source] take(S, Int) -> DynSource

pub fn[A : Source, B : Source] take_crossfade_with(A, B, @core.Duration) -> DynSource

pub fn[S : Source] take_duration(S, @core.Duration) -> DynSource

pub fn[S : Source] to_dyn(S) -> DynSource

pub fn[S : Source] track_position(S) -> TrackPosition

pub fn[S : Source] uniform(S, Int, Int) -> DynSource

pub fn white(Int) -> WhiteUniform

pub fn zero(Int, Int) -> DynSource

pub fn zero_samples(Int, Int, Int) -> DynSource

// Errors
pub suberror DecoderError {
  Backend(@decoder.DecoderError)
  UnrecognizedFormat
}
pub impl Eq for DecoderError
pub impl Show for DecoderError

pub suberror PlayError {
  DecoderError(DecoderError)
}
pub impl Eq for PlayError
pub impl Show for PlayError

pub suberror SeekError {
  NotSupported
}
pub fn SeekError::source_intact(Self) -> Bool
pub impl Eq for SeekError
pub impl Show for SeekError

pub suberror StreamError {
  PlayStreamError(@core.PlayStreamError)
  DefaultStreamConfigError(@core.DefaultStreamConfigError)
  BuildStreamError(@core.BuildStreamError)
  SupportedStreamConfigsError(@core.SupportedStreamConfigsError)
  NoDevice
  UnsupportedSampleFormat
}
pub impl Eq for StreamError
pub impl Show for StreamError

// Types and methods
pub struct Amplify {
  input : DynSource
  factor : Ref[Double]
}
pub fn Amplify::inner(Self) -> DynSource
pub fn Amplify::inner_mut(Self) -> DynSource
pub fn Amplify::into_inner(Self) -> DynSource
pub fn[S : Source] Amplify::new(S, Double) -> Self
pub fn Amplify::set_factor(Self, Double) -> Unit
pub fn Amplify::set_log_factor(Self, Double) -> Unit
pub impl Source for Amplify

pub struct AutomaticGainControl {
  input : DynSource
  target_level : Ref[Double]
  absolute_max_gain : Ref[Double]
  current_gain : Ref[Double]
  attack_coeff : Ref[Double]
  release_coeff : Ref[Double]
  agc_control : Ref[Bool]
}
pub fn AutomaticGainControl::channels(Self) -> Int
pub fn AutomaticGainControl::get_absolute_max_gain(Self) -> Ref[Double]
pub fn AutomaticGainControl::get_agc_control(Self) -> Ref[Bool]
pub fn AutomaticGainControl::get_attack_coeff(Self) -> Ref[Double]
pub fn AutomaticGainControl::get_release_coeff(Self) -> Ref[Double]
pub fn AutomaticGainControl::get_target_level(Self) -> Ref[Double]
pub fn AutomaticGainControl::inner(Self) -> DynSource
pub fn AutomaticGainControl::inner_mut(Self) -> DynSource
pub fn[S : Source] AutomaticGainControl::new(S, Double, @core.Duration, @core.Duration, Double) -> Self
pub fn AutomaticGainControl::next(Self) -> Double?
pub fn AutomaticGainControl::sample_rate(Self) -> Int
pub fn AutomaticGainControl::set_enabled(Self, Bool) -> Unit
pub impl Source for AutomaticGainControl

pub struct BltFilter {
  input : DynSource
  mode : Ref[BltMode]
  freq : Ref[Int]
  q : Ref[Double]
  b0 : Ref[Double]
  b1 : Ref[Double]
  b2 : Ref[Double]
  a1 : Ref[Double]
  a2 : Ref[Double]
  x1 : Ref[Double]
  x2 : Ref[Double]
  y1 : Ref[Double]
  y2 : Ref[Double]
}
pub fn BltFilter::channels(Self) -> Int
pub fn BltFilter::inner(Self) -> DynSource
pub fn BltFilter::inner_mut(Self) -> DynSource
pub fn BltFilter::into_inner(Self) -> DynSource
pub fn BltFilter::next(Self) -> Double?
pub fn BltFilter::sample_rate(Self) -> Int
pub fn BltFilter::to_high_pass(Self, Int) -> Unit
pub fn BltFilter::to_high_pass_with_q(Self, Int, Double) -> Unit
pub fn BltFilter::to_low_pass(Self, Int) -> Unit
pub fn BltFilter::to_low_pass_with_q(Self, Int, Double) -> Unit
pub impl Source for BltFilter

pub enum BltMode {
  LowPass
  HighPass
}
pub impl Eq for BltMode
pub impl Show for BltMode

pub struct Blue {
  sample_rate : Int
  white_noise : WhiteGaussian
  prev_white : Ref[Double]
}
pub fn Blue::channels(Self) -> Int
pub fn Blue::new(Int) -> Self
pub fn Blue::next(Self) -> Double?
pub fn Blue::sample_rate(Self) -> Int
pub impl Source for Blue

pub struct Brownian {
  sample_rate : Int
  white_noise : WhiteGaussian
  accumulator : Ref[Double]
  leak_factor : Ref[Double]
  scale : Ref[Double]
}
pub fn Brownian::channels(Self) -> Int
pub fn Brownian::new(Int) -> Self
pub fn Brownian::next(Self) -> Double?
pub fn Brownian::sample_rate(Self) -> Int
pub impl Source for Brownian

pub struct Buffered {
  inner : SamplesBuffer
}
pub fn Buffered::channels(Self) -> Int
pub fn Buffered::inner(Self) -> SamplesBuffer
pub fn Buffered::inner_mut(Self) -> SamplesBuffer
pub fn Buffered::into_inner(Self) -> SamplesBuffer
pub fn[S : Source] Buffered::new(S) -> Self
pub fn Buffered::next(Self) -> Double?
pub fn Buffered::sample_rate(Self) -> Int
pub impl Source for Buffered

pub struct ChannelCountConverter {
  inner : DynSource
  to : Int
}
pub fn ChannelCountConverter::inner_mut(Self) -> DynSource
pub fn ChannelCountConverter::into_inner(Self) -> DynSource
pub fn[S : Source] ChannelCountConverter::new(S, Int, Int) -> Self
pub impl Source for ChannelCountConverter

pub struct ChannelVolume {
  input : DynSource
  channel_factors : Ref[Array[Double]]
  current_channel : Ref[Int]
  current_sample : Ref[Double?]
}
pub fn ChannelVolume::inner(Self) -> DynSource
pub fn ChannelVolume::inner_mut(Self) -> DynSource
pub fn ChannelVolume::into_inner(Self) -> DynSource
pub fn[S : Source] ChannelVolume::new(S, Array[Double]) -> Self
pub fn ChannelVolume::set_volume(Self, Int, Double) -> Unit
pub impl Source for ChannelVolume

pub struct Chirp {
  sample_rate : Int
  start_frequency : Double
  end_frequency : Double
  total_samples : Int
  elapsed_samples : Ref[Int]
  phase : Ref[Double]
}
pub fn Chirp::channels(Self) -> Int
pub fn Chirp::next(Self) -> Double?
pub fn Chirp::sample_rate(Self) -> Int
pub impl Source for Chirp

pub struct ControlledQueueSource {
  inner : SourcesQueueOutput
  controls : SinkControls
}
pub fn ControlledQueueSource::channels(Self) -> Int
pub fn ControlledQueueSource::next(Self) -> Double?
pub fn ControlledQueueSource::sample_rate(Self) -> Int
pub impl Source for ControlledQueueSource

pub struct Crossfade {
  inner : DynSource
}
pub fn Crossfade::inner(Self) -> DynSource
pub fn Crossfade::inner_mut(Self) -> DynSource
pub fn Crossfade::into_inner(Self) -> DynSource
pub fn[A : Source, B : Source] Crossfade::new(A, B, @core.Duration) -> Self
pub impl Source for Crossfade

pub struct Decoder {
  inner : @decoder.DecodedSamples
  seekable : Bool
  allow_backward_seek : Bool
  kind : DecoderKind
}
pub fn Decoder::builder() -> DecoderBuilder
pub fn Decoder::channels(Self) -> Int
pub fn Decoder::new(Bytes) -> Self raise DecoderError
pub fn Decoder::new_flac(Bytes) -> Self raise DecoderError
pub fn Decoder::new_looped(Bytes) -> LoopedDecoder raise DecoderError
pub fn Decoder::new_mp3(Bytes) -> Self raise DecoderError
pub fn Decoder::new_mp4a(Bytes) -> Self raise DecoderError
pub fn Decoder::new_vorbis(Bytes) -> Self raise DecoderError
pub fn Decoder::new_wav(Bytes) -> Self raise DecoderError
pub fn Decoder::next(Self) -> Double?
pub fn Decoder::sample_rate(Self) -> Int
pub fn Decoder::try_from_file(StringView) -> Self raise DecoderError
pub fn Decoder::try_from_file_looped(StringView) -> LoopedDecoder raise DecoderError
pub impl Source for Decoder

pub struct DecoderBuilder {
  data : Bytes?
  settings : Settings
}
pub fn DecoderBuilder::build(Self) -> Decoder raise DecoderError
pub fn DecoderBuilder::build_looped(Self) -> LoopedDecoder raise DecoderError
pub fn DecoderBuilder::new() -> Self
pub fn DecoderBuilder::with_byte_len(Self, Int) -> Self
pub fn DecoderBuilder::with_coarse_seek(Self, Bool) -> Self
pub fn DecoderBuilder::with_data(Self, Bytes) -> Self
pub fn DecoderBuilder::with_gapless(Self, Bool) -> Self
pub fn DecoderBuilder::with_hint(Self, StringView) -> Self
pub fn DecoderBuilder::with_mime_type(Self, StringView) -> Self
pub fn DecoderBuilder::with_seekable(Self, Bool) -> Self

type DecoderKind
pub impl Eq for DecoderKind
pub impl Show for DecoderKind

pub struct Delay {
  inner : DynSource
}
pub fn Delay::inner(Self) -> DynSource
pub fn Delay::inner_mut(Self) -> DynSource
pub fn Delay::into_inner(Self) -> DynSource
pub fn[S : Source] Delay::new(S, @core.Duration) -> Self
pub impl Source for Delay

pub struct Distortion {
  input : DynSource
  gain : Ref[Double]
  threshold : Ref[Double]
}
pub fn Distortion::inner(Self) -> DynSource
pub fn Distortion::inner_mut(Self) -> DynSource
pub fn Distortion::into_inner(Self) -> DynSource
pub fn[S : Source] Distortion::new(S, Double, Double) -> Self
pub fn[S : Source] Distortion::new_with_threshold(S, Double) -> Self
pub fn Distortion::set_gain(Self, Double) -> Unit
pub fn Distortion::set_threshold(Self, Double) -> Unit
pub fn[S : Source] Distortion::with_gain(S, Double, Double) -> Self
pub impl Source for Distortion

pub struct Done {
  input : DynSource
  signal : Ref[Int]
  signal_sent : Ref[Bool]
}
pub fn Done::channels(Self) -> Int
pub fn Done::inner(Self) -> DynSource
pub fn Done::inner_mut(Self) -> DynSource
pub fn Done::into_inner(Self) -> DynSource
pub fn[S : Source] Done::new(S, Ref[Int]) -> Self
pub fn Done::next(Self) -> Double?
pub fn Done::sample_rate(Self) -> Int
pub impl Source for Done

pub struct DynSource {
  next_sample : () -> Double?
  channels_fn : () -> Int
  sample_rate_fn : () -> Int
  current_span_len_fn : () -> Int?
  total_duration_fn : () -> @core.Duration?
  try_seek_fn : (@core.Duration) -> Result[Unit, SeekError]
}
pub fn DynSource::channels(Self) -> Int
pub fn DynSource::current_span_len(Self) -> Int?
pub fn DynSource::new(() -> Double?, Int, Int, current_span_len? : () -> Int?, total_duration? : () -> @core.Duration?, try_seek? : (@core.Duration) -> Result[Unit, SeekError]) -> Self
pub fn DynSource::new_dynamic(() -> Double?, () -> Int, () -> Int, current_span_len? : () -> Int?, total_duration? : () -> @core.Duration?, try_seek? : (@core.Duration) -> Result[Unit, SeekError]) -> Self
pub fn DynSource::next(Self) -> Double?
pub fn DynSource::sample_rate(Self) -> Int
pub fn DynSource::total_duration(Self) -> @core.Duration?
pub fn DynSource::try_seek(Self, @core.Duration) -> Unit raise SeekError
pub impl Source for DynSource

pub struct Empty {
  inner : DynSource
}
pub fn Empty::inner(Self) -> DynSource
pub fn Empty::inner_mut(Self) -> DynSource
pub fn Empty::into_inner(Self) -> DynSource
pub fn Empty::new(Int, Int) -> Self
pub impl Source for Empty

pub struct EmptyCallback {
  callback : () -> Unit
}
pub fn EmptyCallback::channels(Self) -> Int
pub fn EmptyCallback::new(() -> Unit) -> Self
pub fn EmptyCallback::next(Self) -> Double?
pub fn EmptyCallback::sample_rate(Self) -> Int
pub impl Source for EmptyCallback

pub struct FadeIn {
  inner : DynSource
}
pub fn FadeIn::inner(Self) -> DynSource
pub fn FadeIn::inner_mut(Self) -> DynSource
pub fn FadeIn::into_inner(Self) -> DynSource
pub fn[S : Source] FadeIn::new(S, @core.Duration) -> Self
pub impl Source for FadeIn

pub struct FadeOut {
  inner : DynSource
}
pub fn FadeOut::inner(Self) -> DynSource
pub fn FadeOut::inner_mut(Self) -> DynSource
pub fn FadeOut::into_inner(Self) -> DynSource
pub fn[S : Source] FadeOut::new(S, @core.Duration) -> Self
pub impl Source for FadeOut

pub struct FixedSamplesBuffer {
  channels : Int
  sample_rate : Int
  samples : Array[Double]
  cursor : Ref[Int]
  duration : @core.Duration?
}
pub fn FixedSamplesBuffer::new(Int, Int, Array[Double]) -> Self
pub impl FixedSource for FixedSamplesBuffer

pub struct FixedSourceAdapter {
  inner : DynSource
}
pub fn FixedSourceAdapter::channels(Self) -> Int
pub fn FixedSourceAdapter::inner(Self) -> DynSource
pub fn[S : FixedSource] FixedSourceAdapter::new(S) -> Self
pub fn FixedSourceAdapter::next(Self) -> Double?
pub fn FixedSourceAdapter::sample_rate(Self) -> Int
pub impl Source for FixedSourceAdapter

pub struct FromFactoryIter[S] {
  factory : () -> S?
  current : Ref[DynSource?]
  channels : Ref[Int]
  sample_rate : Ref[Int]
}
pub fn[S] FromFactoryIter::channels(Self[S]) -> Int
pub fn[S : Source] FromFactoryIter::next(Self[S]) -> Double?
pub fn[S] FromFactoryIter::sample_rate(Self[S]) -> Int
pub impl[S : Source] Source for FromFactoryIter[S]

pub struct FromIter {
  sources : Ref[Array[DynSource]]
  current : Ref[DynSource]
  has_current : Ref[Bool]
}
pub fn FromIter::channels(Self) -> Int
pub fn FromIter::next(Self) -> Double?
pub fn FromIter::sample_rate(Self) -> Int
pub impl Source for FromIter

pub enum Function {
  Sine
  Triangle
  Square
  Sawtooth
}
pub fn Function::sawtooth() -> Self
pub fn Function::sine() -> Self
pub fn Function::square() -> Self
pub fn Function::triangle() -> Self
pub impl Eq for Function
pub impl Show for Function

pub struct GeneratorFunction {
  generator : (Double) -> Double
}
pub fn GeneratorFunction::new((Double) -> Double) -> Self

pub struct Limit {
  input : DynSource
  settings : LimitSettings
  attack_coeff : Double
  release_coeff : Double
  integrators : Ref[Array[Double]]
  peaks : Ref[Array[Double]]
  position : Ref[Int]
}
pub fn Limit::inner(Self) -> DynSource
pub fn Limit::inner_mut(Self) -> DynSource
pub fn Limit::into_inner(Self) -> DynSource
pub fn[S : Source] Limit::new(S, LimitSettings) -> Self
pub impl Source for Limit

pub struct LimitSettings {
  min_value : Double
  max_value : Double
  threshold : Double
  knee_width : Double
  attack : @core.Duration
  release : @core.Duration
}
pub fn LimitSettings::broadcast() -> Self
pub fn LimitSettings::default() -> Self
pub fn LimitSettings::dynamic_content() -> Self
pub fn LimitSettings::gaming() -> Self
pub fn LimitSettings::live_performance() -> Self
pub fn LimitSettings::mastering() -> Self
pub fn LimitSettings::new() -> Self
pub fn LimitSettings::with_attack(Self, @core.Duration) -> Self
pub fn LimitSettings::with_knee_width(Self, Double) -> Self
pub fn LimitSettings::with_max(Self, Double) -> Self
pub fn LimitSettings::with_min(Self, Double) -> Self
pub fn LimitSettings::with_release(Self, @core.Duration) -> Self
pub fn LimitSettings::with_threshold(Self, Double) -> Self
pub impl Eq for LimitSettings
pub impl Show for LimitSettings

pub struct LinearGainRamp {
  inner : DynSource
}
pub fn LinearGainRamp::inner(Self) -> DynSource
pub fn LinearGainRamp::inner_mut(Self) -> DynSource
pub fn LinearGainRamp::into_inner(Self) -> DynSource
pub fn[S : Source] LinearGainRamp::new(S, Double, Double, @core.Duration) -> Self
pub fn[S : Source] LinearGainRamp::new_with_clamp(S, Double, Double, @core.Duration, Bool) -> Self
pub impl Source for LinearGainRamp

pub struct LoopedDecoder {
  channels : Int
  sample_rate : Int
  samples : Array[Double]
  cursor : Ref[Int]
  seekable : Bool
}
pub fn LoopedDecoder::channels(Self) -> Int
pub fn LoopedDecoder::next(Self) -> Double?
pub fn LoopedDecoder::sample_rate(Self) -> Int
pub impl Source for LoopedDecoder

pub struct Mix {
  inner : DynSource
}
pub fn Mix::inner(Self) -> DynSource
pub fn Mix::inner_mut(Self) -> DynSource
pub fn Mix::into_inner(Self) -> DynSource
pub fn[A : Source, B : Source] Mix::new(A, B) -> Self
pub impl Source for Mix

pub struct Mixer {
  has_pending : Ref[Bool]
  pending_sources : Ref[Array[DynSource]]
  channels : Int
  sample_rate : Int
}
pub fn[S : Source] Mixer::add(Self, S) -> Unit

pub struct MixerSource {
  current_sources : Ref[Array[DynSource]]
  input : Mixer
  sample_count : Ref[Int]
}
pub fn MixerSource::channels(Self) -> Int
pub fn MixerSource::next(Self) -> Double?
pub fn MixerSource::sample_rate(Self) -> Int
pub impl Source for MixerSource

pub struct OutputStream {
  config : OutputStreamConfig
  mixer : Mixer
  _stream : @spec.Stream
  log_on_drop : Ref[Bool]
}
pub fn OutputStream::config(Self) -> OutputStreamConfig
pub fn OutputStream::log_on_drop(Self, Bool) -> Unit
pub fn OutputStream::mixer(Self) -> Mixer
pub fn OutputStream::open(@spec.Device, OutputStreamConfig, (@core.StreamError) -> Unit) -> Self raise StreamError

pub struct OutputStreamBuilder {
  device : @spec.Device?
  config : OutputStreamConfig
  error_callback : (@core.StreamError) -> Unit
}
pub fn OutputStreamBuilder::default() -> Self
pub fn OutputStreamBuilder::from_default_device() -> Self raise StreamError
pub fn OutputStreamBuilder::from_device(@spec.Device) -> Self raise StreamError
pub fn OutputStreamBuilder::open_default_stream() -> OutputStream raise StreamError
pub fn OutputStreamBuilder::open_stream(Self) -> OutputStream raise StreamError
pub fn OutputStreamBuilder::open_stream_or_fallback(Self) -> OutputStream raise StreamError
pub fn OutputStreamBuilder::with_buffer_size(Self, @core.BufferSize) -> Self
pub fn OutputStreamBuilder::with_channels(Self, Int) -> Self
pub fn OutputStreamBuilder::with_config(Self, @core.StreamConfig) -> Self
pub fn OutputStreamBuilder::with_device(Self, @spec.Device) -> Self
pub fn OutputStreamBuilder::with_error_callback(Self, (@core.StreamError) -> Unit) -> Self
pub fn OutputStreamBuilder::with_sample_format(Self, @core.SampleFormat) -> Self
pub fn OutputStreamBuilder::with_sample_rate(Self, Int) -> Self
pub fn OutputStreamBuilder::with_supported_config(Self, @core.SupportedStreamConfig) -> Self

pub struct OutputStreamConfig {
  channel_count : Int
  sample_rate : Int
  buffer_size : @core.BufferSize
  sample_format : @core.SampleFormat
}
pub fn OutputStreamConfig::buffer_size(Self) -> @core.BufferSize
pub fn OutputStreamConfig::channel_count(Self) -> Int
pub fn OutputStreamConfig::default() -> Self
pub fn OutputStreamConfig::sample_format(Self) -> @core.SampleFormat
pub fn OutputStreamConfig::sample_rate(Self) -> Int
pub impl Eq for OutputStreamConfig
pub impl Show for OutputStreamConfig

pub struct Pausable {
  input : DynSource
  paused_channels : Ref[Int?]
  remaining_paused_samples : Ref[Int]
}
pub fn Pausable::channels(Self) -> Int
pub fn Pausable::inner(Self) -> DynSource
pub fn Pausable::inner_mut(Self) -> DynSource
pub fn Pausable::into_inner(Self) -> DynSource
pub fn Pausable::is_paused(Self) -> Bool
pub fn Pausable::next(Self) -> Double?
pub fn Pausable::sample_rate(Self) -> Int
pub fn Pausable::set_paused(Self, Bool) -> Unit
pub impl Source for Pausable

pub struct PeriodicAccess {
  input : DynSource
  every_samples : Int
  remaining : Ref[Int]
  callback : (DynSource) -> Unit
}
pub fn PeriodicAccess::channels(Self) -> Int
pub fn PeriodicAccess::inner(Self) -> DynSource
pub fn PeriodicAccess::inner_mut(Self) -> DynSource
pub fn PeriodicAccess::into_inner(Self) -> DynSource
pub fn PeriodicAccess::next(Self) -> Double?
pub fn PeriodicAccess::sample_rate(Self) -> Int
pub impl Source for PeriodicAccess

pub struct Pink {
  sample_rate : Int
  state : Ref[UInt64]
  prev : Ref[Double]
}
pub fn Pink::channels(Self) -> Int
pub fn Pink::new(Int) -> Self
pub fn Pink::next(Self) -> Double?
pub fn Pink::sample_rate(Self) -> Int
pub impl Source for Pink

pub struct QueueSignal {
  done : Ref[Bool]
}
pub fn QueueSignal::is_done(Self) -> Bool
pub fn QueueSignal::mark_done(Self) -> Unit

type QueuedSource

pub struct Repeat {
  inner : DynSource
}
pub fn Repeat::inner(Self) -> DynSource
pub fn Repeat::inner_mut(Self) -> DynSource
pub fn Repeat::into_inner(Self) -> DynSource
pub fn[S : Source] Repeat::new(S) -> Self
pub impl Source for Repeat

pub struct SampleRateConverter {
  inner : DynSource
  to : Int
  channels : Int
}
pub fn SampleRateConverter::inner_mut(Self) -> DynSource
pub fn SampleRateConverter::into_inner(Self) -> DynSource
pub fn[S : Source] SampleRateConverter::new(S, Int, Int, Int) -> Self
pub impl Source for SampleRateConverter

pub struct SampleTypeConverter {
  inner : DynSource
}
pub fn SampleTypeConverter::inner_mut(Self) -> DynSource
pub fn SampleTypeConverter::into_inner(Self) -> DynSource
pub fn[S : Source] SampleTypeConverter::new(S) -> Self
pub impl Source for SampleTypeConverter

pub struct SamplesBuffer {
  channels : Int
  sample_rate : Int
  samples : Array[Double]
  cursor : Ref[Int]
}
pub fn SamplesBuffer::amplify(Self, Double) -> DynSource
pub fn SamplesBuffer::channels(Self) -> Int
pub fn SamplesBuffer::new(Int, Int, Array[Double]) -> Self
pub fn SamplesBuffer::next(Self) -> Double?
pub fn SamplesBuffer::repeat_infinite(Self) -> DynSource
pub fn SamplesBuffer::sample_rate(Self) -> Int
pub impl Source for SamplesBuffer

pub struct SawtoothWave {
  inner : SignalGenerator
}
pub fn SawtoothWave::channels(Self) -> Int
pub fn SawtoothWave::new(Double) -> Self
pub fn SawtoothWave::next(Self) -> Double?
pub fn SawtoothWave::sample_rate(Self) -> Int
pub impl Source for SawtoothWave

pub struct Settings {
  byte_len : Int?
  coarse_seek : Bool
  gapless : Bool
  hint : String?
  mime_type : String?
  is_seekable : Bool
}
pub fn Settings::default() -> Self
pub impl Eq for Settings
pub impl Show for Settings

pub enum SignalFunction {
  Sine
  Square
  Sawtooth
  Triangle
}
pub impl Eq for SignalFunction
pub impl Show for SignalFunction

pub struct SignalGenerator {
  channels : Int
  sample_rate : Int
  frequency : Double
  function : SignalFunction
  phase : Ref[Double]
}
pub fn SignalGenerator::channels(Self) -> Int
pub fn SignalGenerator::from_function(Int, Double, Function) -> Self
pub fn SignalGenerator::new(Int, Double, SignalFunction) -> Self
pub fn SignalGenerator::next(Self) -> Double?
pub fn SignalGenerator::sample_rate(Self) -> Int
pub fn SignalGenerator::with_function(Int, Double, Function) -> Self
pub fn SignalGenerator::with_generator(Int, Double, GeneratorFunction) -> DynSource
pub impl Source for SignalGenerator

pub struct SineWave {
  inner : SignalGenerator
}
pub fn SineWave::channels(Self) -> Int
pub fn SineWave::new(Double) -> Self
pub fn SineWave::next(Self) -> Double?
pub fn SineWave::sample_rate(Self) -> Int
pub impl Source for SineWave

pub struct Sink {
  queue_tx : SourcesQueueInput
  queue_rx : SourcesQueueOutput
  controls : SinkControls
  detached : Ref[Bool]
  last_signal : Ref[QueueSignal?]
}
pub fn[S : Source] Sink::append(Self, S) -> Unit
pub fn Sink::clear(Self) -> Unit
pub fn Sink::connect_new(Mixer) -> Self
pub fn Sink::detach(Self) -> Unit
pub fn Sink::empty(Self) -> Bool
pub fn Sink::get_pos(Self) -> @core.Duration
pub fn Sink::is_paused(Self) -> Bool
pub fn Sink::len(Self) -> Int
pub fn Sink::new() -> (Self, ControlledQueueSource)
pub fn Sink::pause(Self) -> Unit
pub fn Sink::play(Self) -> Unit
pub fn Sink::set_speed(Self, Double) -> Unit
pub fn Sink::set_volume(Self, Double) -> Unit
pub fn Sink::skip_one(Self) -> Unit
pub fn Sink::sleep_until_end(Self) -> Unit
pub fn Sink::speed(Self) -> Double
pub fn Sink::stop(Self) -> Unit
pub fn Sink::try_seek(Self, @core.Duration) -> Unit raise SeekError
pub fn Sink::volume(Self) -> Double

pub struct SinkControls {
  pause : Ref[Bool]
  stopped : Ref[Bool]
  to_clear : Ref[Int]
  volume : Ref[Double]
  speed : Ref[Double]
  sound_count : Ref[Int]
  position : Ref[@core.Duration]
}

pub struct SkipDuration {
  inner : DynSource
}
pub fn SkipDuration::inner(Self) -> DynSource
pub fn SkipDuration::inner_mut(Self) -> DynSource
pub fn SkipDuration::into_inner(Self) -> DynSource
pub fn[S : Source] SkipDuration::new(S, @core.Duration) -> Self
pub impl Source for SkipDuration

pub struct Skippable {
  input : DynSource
  do_skip : Ref[Bool]
}
pub fn Skippable::channels(Self) -> Int
pub fn Skippable::inner(Self) -> DynSource
pub fn Skippable::inner_mut(Self) -> DynSource
pub fn Skippable::into_inner(Self) -> DynSource
pub fn Skippable::next(Self) -> Double?
pub fn Skippable::sample_rate(Self) -> Int
pub fn Skippable::skip(Self) -> Unit
pub impl Source for Skippable

pub struct SourcesQueueInput {
  next_sounds : Ref[Array[QueuedSource]]
  keep_alive_if_empty : Ref[Bool]
}
pub fn[S : Source] SourcesQueueInput::append(Self, S) -> Unit
pub fn[S : Source] SourcesQueueInput::append_with_signal(Self, S) -> QueueSignal
pub fn SourcesQueueInput::clear(Self) -> Int
pub fn SourcesQueueInput::set_keep_alive_if_empty(Self, Bool) -> Unit

pub struct SourcesQueueOutput {
  current : Ref[DynSource]
  current_is_fallback : Ref[Bool]
  prefetched : Ref[Double?]
  has_prefetched : Ref[Bool]
  signal_after_end : Ref[QueueSignal?]
  input : SourcesQueueInput
}
pub fn SourcesQueueOutput::channels(Self) -> Int
pub fn SourcesQueueOutput::next(Self) -> Double?
pub fn SourcesQueueOutput::sample_rate(Self) -> Int
pub fn SourcesQueueOutput::skip_one(Self) -> Unit
pub impl Source for SourcesQueueOutput

pub struct Spatial {
  inner : SpatialSource
}
pub fn Spatial::channels(Self) -> Int
pub fn Spatial::inner(Self) -> SpatialSource
pub fn Spatial::inner_mut(Self) -> SpatialSource
pub fn Spatial::into_inner(Self) -> SpatialSource
pub fn[S : Source] Spatial::new(S, Array[Double], Array[Double], Array[Double]) -> Self
pub fn Spatial::next(Self) -> Double?
pub fn Spatial::sample_rate(Self) -> Int
pub fn Spatial::set_positions(Self, Array[Double], Array[Double], Array[Double]) -> Unit
pub impl Source for Spatial

pub struct SpatialSink {
  sink : Sink
  emitter_position : Ref[Array[Double]]
  left_ear : Ref[Array[Double]]
  right_ear : Ref[Array[Double]]
}
pub fn[S : Source] SpatialSink::append(Self, S) -> Unit
pub fn SpatialSink::clear(Self) -> Unit
pub fn SpatialSink::connect_new(Mixer, Array[Double], Array[Double], Array[Double]) -> Self
pub fn SpatialSink::detach(Self) -> Unit
pub fn SpatialSink::empty(Self) -> Bool
pub fn SpatialSink::get_pos(Self) -> @core.Duration
pub fn SpatialSink::is_paused(Self) -> Bool
pub fn SpatialSink::len(Self) -> Int
pub fn SpatialSink::pause(Self) -> Unit
pub fn SpatialSink::play(Self) -> Unit
pub fn SpatialSink::set_emitter_position(Self, Array[Double]) -> Unit
pub fn SpatialSink::set_left_ear_position(Self, Array[Double]) -> Unit
pub fn SpatialSink::set_right_ear_position(Self, Array[Double]) -> Unit
pub fn SpatialSink::set_speed(Self, Double) -> Unit
pub fn SpatialSink::set_volume(Self, Double) -> Unit
pub fn SpatialSink::skip_one(Self) -> Unit
pub fn SpatialSink::sleep_until_end(Self) -> Unit
pub fn SpatialSink::speed(Self) -> Double
pub fn SpatialSink::stop(Self) -> Unit
pub fn SpatialSink::try_seek(Self, @core.Duration) -> Unit raise SeekError
pub fn SpatialSink::volume(Self) -> Double

pub struct SpatialSource {
  input : DynSource
  emitter_position : Ref[Array[Double]]
  left_ear : Ref[Array[Double]]
  right_ear : Ref[Array[Double]]
  left_gain : Ref[Double]
  right_gain : Ref[Double]
  pending_mono : Ref[Double]
  has_pending : Ref[Bool]
  pending_channel : Ref[Int]
}
pub fn SpatialSource::channels(Self) -> Int
pub fn[S : Source] SpatialSource::new(S, Array[Double], Array[Double], Array[Double]) -> Self
pub fn SpatialSource::next(Self) -> Double?
pub fn SpatialSource::sample_rate(Self) -> Int
pub fn SpatialSource::set_positions(Self, Array[Double], Array[Double], Array[Double]) -> Unit
pub impl Source for SpatialSource

pub struct Speed {
  input : DynSource
  factor : Ref[Double]
}
pub fn Speed::inner(Self) -> DynSource
pub fn Speed::inner_mut(Self) -> DynSource
pub fn Speed::into_inner(Self) -> DynSource
pub fn[S : Source] Speed::new(S, Double) -> Self
pub fn Speed::set_factor(Self, Double) -> Unit
pub impl Source for Speed

pub struct SquareWave {
  inner : SignalGenerator
}
pub fn SquareWave::channels(Self) -> Int
pub fn SquareWave::new(Double) -> Self
pub fn SquareWave::next(Self) -> Double?
pub fn SquareWave::sample_rate(Self) -> Int
pub impl Source for SquareWave

pub struct StaticSamplesBuffer {
  channels : Int
  sample_rate : Int
  samples : Array[Double]
  cursor : Ref[Int]
}
pub fn StaticSamplesBuffer::channels(Self) -> Int
pub fn StaticSamplesBuffer::new(Int, Int, Array[Double]) -> Self
pub fn StaticSamplesBuffer::next(Self) -> Double?
pub fn StaticSamplesBuffer::sample_rate(Self) -> Int
pub impl Source for StaticSamplesBuffer

pub struct Stoppable {
  input : DynSource
  stopped : Ref[Bool]
}
pub fn Stoppable::channels(Self) -> Int
pub fn Stoppable::inner(Self) -> DynSource
pub fn Stoppable::inner_mut(Self) -> DynSource
pub fn Stoppable::into_inner(Self) -> DynSource
pub fn Stoppable::next(Self) -> Double?
pub fn Stoppable::sample_rate(Self) -> Int
pub fn Stoppable::stop(Self) -> Unit
pub impl Source for Stoppable

pub struct TakeDuration {
  inner : DynSource
  requested_duration : @core.Duration
  requested_samples : Int
  remaining_samples : Ref[Int]
  filter_fadeout : Ref[Bool]
}
pub fn TakeDuration::clear_filter(Self) -> Unit
pub fn TakeDuration::inner(Self) -> DynSource
pub fn TakeDuration::inner_mut(Self) -> DynSource
pub fn TakeDuration::into_inner(Self) -> DynSource
pub fn[S : Source] TakeDuration::new(S, @core.Duration) -> Self
pub fn TakeDuration::set_filter_fadeout(Self) -> Unit
pub impl Source for TakeDuration

pub struct TrackPosition {
  input : DynSource
  samples_counted : Ref[Int]
  offset_duration : Ref[@core.Duration]
  current_span_sample_rate : Ref[Int]
  current_span_channels : Ref[Int]
  current_span_len : Ref[Int?]
}
pub fn TrackPosition::channels(Self) -> Int
pub fn TrackPosition::get_pos(Self) -> @core.Duration
pub fn TrackPosition::inner(Self) -> DynSource
pub fn TrackPosition::inner_mut(Self) -> DynSource
pub fn TrackPosition::into_inner(Self) -> DynSource
pub fn TrackPosition::next(Self) -> Double?
pub fn TrackPosition::sample_rate(Self) -> Int
pub impl Source for TrackPosition

pub struct TriangleWave {
  inner : SignalGenerator
}
pub fn TriangleWave::channels(Self) -> Int
pub fn TriangleWave::new(Double) -> Self
pub fn TriangleWave::next(Self) -> Double?
pub fn TriangleWave::sample_rate(Self) -> Int
pub impl Source for TriangleWave

pub struct UniformSourceIterator {
  input : DynSource
  target_channels : Int
  target_sample_rate : Int
  total_duration : @core.Duration?
}
pub fn UniformSourceIterator::channels(Self) -> Int
pub fn UniformSourceIterator::inner_mut(Self) -> DynSource
pub fn[S : Source] UniformSourceIterator::new(S, Int, Int) -> Self
pub fn UniformSourceIterator::next(Self) -> Double?
pub fn UniformSourceIterator::sample_rate(Self) -> Int
pub impl Source for UniformSourceIterator

pub struct Velvet {
  sample_rate : Int
  state : Ref[UInt64]
  grid_size : Ref[Double]
  grid_pos : Ref[Double]
  impulse_pos : Ref[Double]
}
pub fn Velvet::channels(Self) -> Int
pub fn Velvet::new(Int) -> Self
pub fn Velvet::new_with_density(Int, Double) -> Self
pub fn Velvet::next(Self) -> Double?
pub fn Velvet::sample_rate(Self) -> Int
pub impl Source for Velvet

pub struct Violet {
  sample_rate : Int
  blue_noise : Blue
  prev : Ref[Double]
}
pub fn Violet::channels(Self) -> Int
pub fn Violet::new(Int) -> Self
pub fn Violet::next(Self) -> Double?
pub fn Violet::sample_rate(Self) -> Int
pub impl Source for Violet

pub struct WhiteGaussian {
  sample_rate : Int
  state : Ref[UInt64]
}
pub fn WhiteGaussian::channels(Self) -> Int
pub fn WhiteGaussian::mean(Self) -> Double
pub fn WhiteGaussian::new(Int) -> Self
pub fn WhiteGaussian::next(Self) -> Double?
pub fn WhiteGaussian::sample_rate(Self) -> Int
pub fn WhiteGaussian::std_dev(Self) -> Double
pub impl Source for WhiteGaussian

pub struct WhiteTriangular {
  sample_rate : Int
  state : Ref[UInt64]
}
pub fn WhiteTriangular::channels(Self) -> Int
pub fn WhiteTriangular::new(Int) -> Self
pub fn WhiteTriangular::next(Self) -> Double?
pub fn WhiteTriangular::sample_rate(Self) -> Int
pub impl Source for WhiteTriangular

pub struct WhiteUniform {
  sample_rate : Int
  state : Ref[UInt64]
}
pub fn WhiteUniform::channels(Self) -> Int
pub fn WhiteUniform::new(Int) -> Self
pub fn WhiteUniform::next(Self) -> Double?
pub fn WhiteUniform::sample_rate(Self) -> Int
pub impl Source for WhiteUniform

pub struct Zero {
  inner : DynSource
}
pub fn Zero::inner(Self) -> DynSource
pub fn Zero::inner_mut(Self) -> DynSource
pub fn Zero::into_inner(Self) -> DynSource
pub fn Zero::new(Int, Int) -> Self
pub fn Zero::new_samples(Int, Int, Int) -> Self
pub impl Source for Zero

// Type aliases
pub type ChannelCount = Int

pub type Sample = Double

pub type SampleRate = Int

// Traits
pub trait FixedSource {
  next(Self) -> Double?
  channels(Self) -> Int
  sample_rate(Self) -> Int
  total_duration(Self) -> @core.Duration?
}

pub trait Source {
  next(Self) -> Double?
  channels(Self) -> Int
  sample_rate(Self) -> Int
  current_span_len(Self) -> Int?
  total_duration(Self) -> @core.Duration?
  try_seek(Self, @core.Duration) -> Unit raise SeekError
}

